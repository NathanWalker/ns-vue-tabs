diff --git a/node_modules/@nativescript/core/ui/list-view/index.ios.js b/node_modules/@nativescript/core/ui/list-view/index.ios.js
index f7119a4..da1570c 100644
--- a/node_modules/@nativescript/core/ui/list-view/index.ios.js
+++ b/node_modules/@nativescript/core/ui/list-view/index.ios.js
@@ -242,6 +242,23 @@ var UITableViewDelegateImpl = (function (_super) {
         }
         return height;
     };
+    UITableViewDelegateImpl.prototype.scrollViewDidScroll = function (
+        scrollView
+    ) {
+        const offsetY = scrollView.contentOffset.y;
+        var _a;
+        var owner =
+            (_a = this._owner) === null || _a === void 0 ? void 0 : _a.deref();
+        if (!owner) {
+            return 0;
+        }
+         owner.notify({
+            eventName: 'scrollChange',
+            object: owner,
+            value: offsetY
+        });
+
+    };
     UITableViewDelegateImpl.ObjCProtocols = [UITableViewDelegate];
     return UITableViewDelegateImpl;
 }(NSObject));
diff --git a/node_modules/@nativescript/core/ui/tab-view/index.d.ts b/node_modules/@nativescript/core/ui/tab-view/index.d.ts
index ab9ec10..dcd4f53 100644
--- a/node_modules/@nativescript/core/ui/tab-view/index.d.ts
+++ b/node_modules/@nativescript/core/ui/tab-view/index.d.ts
@@ -37,6 +37,11 @@ export class TabViewItem extends ViewBase {
 	 */
 	public iconSource: string;
 
+	/**
+	 * Gets or sets the role of the TabViewItem.
+	 */
+	public role: string;
+
 	/**
 	 * Gets or sets the text transform of the tab titles.
 	 *
diff --git a/node_modules/@nativescript/core/ui/tab-view/index.ios.js b/node_modules/@nativescript/core/ui/tab-view/index.ios.js
index 9f192f0..aee624b 100644
--- a/node_modules/@nativescript/core/ui/tab-view/index.ios.js
+++ b/node_modules/@nativescript/core/ui/tab-view/index.ios.js
@@ -223,20 +223,44 @@ export class TabViewItem extends TabViewItemBase {
             const icon = parent._getIcon(this);
             const index = parent.items.indexOf(this);
             const title = getTransformedText(this.title, this.style.textTransform);
-            const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(title, icon, index);
-            updateTitleAndIconPositions(this, tabBarItem, controller);
-            // There is no need to request title styles update here in newer versions as styling is handled by bar appearance instance
-            if (!__VISIONOS__ && SDK_VERSION < 15) {
-                // TODO: Repeating code. Make TabViewItemBase - ViewBase and move the colorProperty on tabViewItem.
-                // Delete the repeating code.
-                const states = getTitleAttributesForStates(parent);
-                applyStatesToItem(tabBarItem, states);
+            if (SDK_VERSION >= 18) {
+                // iOS 18+: use UITab instead of UITabBarItem.
+                // The UITab instances are created and managed at the TabView level,
+                // so here we just update the corresponding tab for this controller.
+                const identifier = `${index}`;
+                const tabController = parent.viewController;
+                try {
+                    const tab = tabController.tabForIdentifier(identifier);
+                    if (tab) {
+                        tab.title = title;
+                        tab.image = icon;
+                    }
+                }
+                catch (e) {
+                    // Fallback: if tabForIdentifier is not available for some reason,
+                    // do not crash â€“ rely on existing tab configuration.
+                }
+            }
+            else {
+                // iOS < 18: keep using UITabBarItem-based configuration.
+                const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(title, icon, index);
+                updateTitleAndIconPositions(this, tabBarItem, controller);
+                // There is no need to request title styles update here in newer versions as styling is handled by bar appearance instance
+                if (!__VISIONOS__ && SDK_VERSION < 15) {
+                    // TODO: Repeating code. Make TabViewItemBase - ViewBase and move the colorProperty on tabViewItem.
+                    // Delete the repeating code.
+                    const states = getTitleAttributesForStates(parent);
+                    applyStatesToItem(tabBarItem, states);
+                }
+                controller.tabBarItem = tabBarItem;
             }
-            controller.tabBarItem = tabBarItem;
         }
     }
     _updateTitleAndIconPositions() {
-        if (!this.__controller || !this.__controller.tabBarItem) {
+        // UITab-based configuration (iOS 18+) does not expose the same per-item
+        // title/icon positioning APIs as UITabBarItem, so we only adjust
+        // positions when using the legacy UITabBarItem setup.
+        if (SDK_VERSION >= 18 || !this.__controller || !this.__controller.tabBarItem) {
             return;
         }
         updateTitleAndIconPositions(this, this.__controller.tabBarItem, this.__controller);
@@ -417,28 +441,75 @@ export class TabView extends TabViewBase {
     setViewControllers(items) {
         const length = items ? items.length : 0;
         if (length === 0) {
-            this._ios.viewControllers = null;
+            if (SDK_VERSION >= 18) {
+                // Clear tabs on iOS 18+ when there are no items.
+                try {
+                    this._ios.tabs = NSArray.arrayWithArray([]);
+                }
+                catch (e) {
+                    // Fallback if tabs API is unavailable for some reason.
+                    this._ios.viewControllers = null;
+                }
+            }
+            else {
+                this._ios.viewControllers = null;
+            }
             return;
         }
-        const controllers = NSMutableArray.alloc().initWithCapacity(length);
-        const states = getTitleAttributesForStates(this);
-        items.forEach((item, i) => {
-            const controller = this.getViewController(item);
-            const icon = this._getIcon(item);
-            const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(item.title || '', icon, i);
-            updateTitleAndIconPositions(item, tabBarItem, controller);
-            if (!__VISIONOS__ && SDK_VERSION < 15) {
-                applyStatesToItem(tabBarItem, states);
+        if (SDK_VERSION >= 18) {
+            // iOS 18+: build UITab instances and assign them to the controller.
+            const tabs = [];
+            const controllers = [];
+            items.forEach((item, i) => {
+                const controller = this.getViewController(item);
+                controllers.push(controller);
+                const icon = this._getIcon(item);
+                const title = item.title || '';
+                const identifier = `${i}`;
+                let tab;
+                if (item.role === 'search') {
+                    tab = UISearchTab.alloc().initWithTitleImageIdentifierViewControllerProvider(title, icon, identifier, (t) => {
+                        return controller;
+                    });
+                }
+                else {
+                    tab = UITab.alloc().initWithTitleImageIdentifierViewControllerProvider(title, icon, identifier, (t) => {
+                        return controller;
+                    });
+                }
+                tabs.push(tab);
+                item.canBeLoaded = true;
+            });
+            try {
+                // Prefer animated setter when available.
+                this._ios.tabs = NSArray.arrayWithArray(tabs);
             }
-            controller.tabBarItem = tabBarItem;
-            controllers.addObject(controller);
-            item.canBeLoaded = true;
-        });
-        if (SDK_VERSION >= 15) {
-            this.updateBarItemAppearance(this._ios.tabBar, states);
+            catch (e) { }
+            this._ios.viewControllers = NSArray.arrayWithArray(controllers);
+            this._ios.customizableViewControllers = null;
+        }
+        else {
+            // iOS < 18: keep using UITabBarItem-based configuration.
+            const controllers = [];
+            const states = getTitleAttributesForStates(this);
+            items.forEach((item, i) => {
+                const controller = this.getViewController(item);
+                const icon = this._getIcon(item);
+                const tabBarItem = UITabBarItem.alloc().initWithTitleImageTag(item.title || '', icon, i);
+                updateTitleAndIconPositions(item, tabBarItem, controller);
+                if (!__VISIONOS__ && SDK_VERSION < 15) {
+                    applyStatesToItem(tabBarItem, states);
+                }
+                controller.tabBarItem = tabBarItem;
+                controllers.push(controller);
+                item.canBeLoaded = true;
+            });
+            if (SDK_VERSION >= 15) {
+                this.updateBarItemAppearance(this._ios.tabBar, states);
+            }
+            this._ios.viewControllers = NSArray.arrayWithArray(controllers);
+            this._ios.customizableViewControllers = null;
         }
-        this._ios.viewControllers = controllers;
-        this._ios.customizableViewControllers = null;
         // When we set this._ios.viewControllers, someone is clearing the moreNavigationController.delegate, so we have to reassign it each time here.
         this._ios.moreNavigationController.delegate = this._moreNavigationControllerDelegate;
     }
@@ -710,8 +781,19 @@ export class TabView extends TabViewBase {
         const containerHeight = container.heightAnchor.constraintEqualToConstant(finalHeight);
         containerHeight.priority = 999;
         NSLayoutConstraint.activateConstraints([containerHeight]);
+
+        // Allow horizontal shrink/expand as tab bar transitions
+        container.setContentCompressionResistancePriorityForAxis(UILayoutPriorityDefaultLow, UILayoutConstraintAxis.Horizontal);
+        container.setContentHuggingPriorityForAxis(UILayoutPriorityDefaultLow, UILayoutConstraintAxis.Horizontal);
         const accessory = UITabAccessory.alloc().initWithContentView(container);
         setAccessory(accessory);
+        // Work around UIKit occasionally caching accessory sizes too aggressively
+        // by explicitly triggering a layout pass on the tab bar.
+        const tabBar = this._ios?.tabBar;
+        if (tabBar) {
+            tabBar.setNeedsLayout();
+            tabBar.layoutIfNeeded();
+        }
         // Keep references for later teardown
         this._bottomAccessoryNsView = nsView;
     }
@@ -732,6 +814,18 @@ var NSTabAccessoryContainer = (function (_super) {
         v._owner = owner;
         return v;
     };
+    NSTabAccessoryContainer.prototype.traitCollectionDidChange = function (previousTraitCollection) {
+        var _a;
+        _super.prototype.traitCollectionDidChange.call(this, previousTraitCollection);
+        if (!previousTraitCollection) {
+            return;
+        }
+        if (((_a = this.traitCollection) === null || _a === void 0 ? void 0 : _a.horizontalSizeClass) !== previousTraitCollection.horizontalSizeClass) {
+            this.invalidateIntrinsicContentSize();
+            this.setNeedsLayout();
+            this.layoutIfNeeded();
+        }
+    };
     NSTabAccessoryContainer.prototype.layoutSubviews = function () {
         var _a;
         _super.prototype.layoutSubviews.call(this);
